<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Legally Distinct Tetromino v2</title>
    
    <!-- Tone.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#202124">

    <!-- Favicons -->
    <link rel="icon" href="./icons/favicon.ico">
    <link rel="apple-touch-icon" href="./icons/apple-touch-icon.png">

    <style>
        :root {
            --bg-color: #202124;
            --ui-bg: #2d2e31;
            --text-color: #f0f0f0;
            --accent-color: #fb8c00; /* Magic Orange */
            --font-main: 'Press Start 2P', monospace;
            --glow-color: rgba(255, 255, 255, 0.5);
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            height: 100dvh; /* Dynamic Viewport Height for Mobile */
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center canvas vertically */
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* --- Canvas Layer --- */
        #game-canvas {
            display: block;
            margin: 0 auto;
            flex-grow: 0; 
            /* Ensure it never exceeds container */
            max-height: 100%; 
            max-width: 100%;
        }

        /* --- UI Overlay Layer --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            background: rgba(32, 33, 36, 0.98);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #555;
            pointer-events: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9);
            width: 95%;
            max-width: 480px; 
            max-height: 95%;
            overflow-y: auto;
        }

        .hidden { display: none !important; }

        h2 { font-size: 18px; margin-bottom: 20px; color: var(--accent-color); }

        /* --- Stats --- */
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 12px;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        .stat-val { color: #fff; }
        .high-score { color: #fcbf49; }

        /* --- Buttons --- */
        button {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 15px 20px;
            font-family: var(--font-main);
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            box-shadow: 0 4px 0 #0d47a1;
            transition: transform 0.05s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #0d47a1; }
        button.secondary { background: #555; box-shadow: 0 4px 0 #333; }
        button.secondary:active { box-shadow: 0 0 0 #333; }

        /* --- Controls Grid --- */
        .controls-grid {
            display: grid;
            grid-template-columns: max-content max-content 25px auto; 
            gap: 12px 5px;
            text-align: left;
            margin-bottom: 15px;
            width: 100%;
            justify-content: center;
            align-items: center;
        }

        .c-col-action { font-size: 9px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.4; }
        .c-col-keys { text-align: right; font-size: 9px; color: #fff; display: flex; justify-content: flex-end; align-items: center; }
        .c-col-or { text-align: center; font-size: 8px; color: #555; }
        .c-col-touch { text-align: left; font-size: 9px; color: #fcbf49; display: flex; align-items: center; }

        .key {
            display: inline-flex; justify-content: center; align-items: center;
            background: #444; padding: 0 5px; border-radius: 3px;
            color: #fcbf49; border-bottom: 2px solid #222;
            font-size: 8px; height: 20px; min-width: 20px; margin-left: 3px;
        }
        
        .touch-label {
            display: inline-block; padding: 3px 5px; border-radius: 3px;
            background: #333; border: 1px solid #444;
            font-size: 8px; color: #eee; white-space: nowrap;
        }

        .arrow-icon { width: 8px; height: 8px; fill: currentColor; }
        .name-input-group { margin: 15px 0; text-align: center; }
        .name-input { background: #222; border: 2px solid #555; color: #fcbf49; font-family: var(--font-main); font-size: 14px; padding: 8px; width: 140px; text-align: center; border-radius: 4px; text-transform: uppercase; letter-spacing: 2px; }
        .name-input:focus { outline: none; border-color: var(--accent-color); }

    </style>
</head>
<body>

<div id="app">
    <!-- Header Removed - Info now on Canvas -->
    
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        
        <!-- Start / Pause / Controls Screen -->
        <div id="start-screen" class="screen">
            <h2 id="screen-title">CONTROLS</h2>
            
            <div id="start-high-score" class="stat-row" style="margin-bottom: 20px; justify-content: center; border: none;">
                <span style="color: #fcbf49;">BEST: <span id="start-high-score-val">0</span> <span id="start-high-score-name" style="font-size:10px; color:#aaa"></span></span>
            </div>

            <div class="controls-grid">
                <!-- Move -->
                <div class="c-col-action">Move</div>
                <div class="c-col-keys">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M7 2 L3 5 L7 8 Z"/></svg></span>
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M3 2 L7 5 L3 8 Z"/></svg></span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">Swipe L/R</span></div>

                <!-- Rotate -->
                <div class="c-col-action">Rotate</div>
                <div class="c-col-keys">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M2 7 L5 3 L8 7 Z"/></svg></span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">Tap</span></div>

                <!-- Soft Drop -->
                <div class="c-col-action">Soft Drop</div>
                <div class="c-col-keys">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M2 3 L5 7 L8 3 Z"/></svg></span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">Swipe Down</span></div>

                <!-- Hold -->
                <div class="c-col-action">Hold Piece</div>
                <div class="c-col-keys">
                    <span class="key">C</span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">Swipe Up</span></div>

                <!-- Hard Drop -->
                <div class="c-col-action">Hard Drop</div>
                <div class="c-col-keys">
                    <span class="key" style="font-size:7px;">SPACE</span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">Hold</span></div> <!-- Updated Label -->

                <!-- Pause -->
                <div class="c-col-action">Pause</div>
                <div class="c-col-keys">
                    <span class="key">P</span>
                </div>
                <div class="c-col-or">or</div>
                <div class="c-col-touch"><span class="touch-label">2-Finger</span></div>
            </div>

            <button id="btn-start">START GAME</button>
            <button id="btn-resume" class="hidden">RESUME</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <h2 style="color:#ff5252">GAME OVER</h2>
            <div class="stat-row"><span>Final Score</span><span class="stat-val" id="final-score">0</span></div>
            <div class="stat-row"><span>Lines Cleared</span><span class="stat-val" id="final-lines">0</span></div>
            
            <div class="name-input-group">
                <div style="font-size:10px; margin-bottom:5px; color:#aaa;">ENTER NAME (5 CHARS)</div>
                <input type="text" id="high-score-name" class="name-input" maxlength="5" placeholder="NAME">
            </div>

            <button id="btn-restart">NEW GAME</button>
            <button id="btn-quit" class="secondary">QUIT</button>
        </div>
    </div>
</div>

<script>
// --- Service Worker ---
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(err => console.log('SW registration failed', err));
    });
}

const COLS = 10;
const ROWS = 20;
const COLORS = {
    I: '#00f0f0', O: '#f0f000', T: '#a000f0', S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#f0a000',
    GHOST: 'rgba(255, 255, 255, 0.15)',
    BG: '#202124',
    GRID: '#2d2e31'
};

const SHAPES = {
    I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    J: [[1,0,0], [1,1,1], [0,0,0]],
    L: [[0,0,1], [1,1,1], [0,0,0]],
    O: [[1,1], [1,1]],
    S: [[0,1,1], [1,1,0], [0,0,0]],
    T: [[0,1,0], [1,1,1], [0,0,0]],
    Z: [[1,1,0], [0,1,1], [0,0,0]]
};

class AudioController {
    constructor() {
        this.enabled = typeof Tone !== 'undefined';
        if (!this.enabled) return;
        
        this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
        this.synth.volume.value = -12;
        this.pluck = new Tone.PluckSynth().toDestination();
        this.pluck.volume.value = -8;
        this.metal = new Tone.MetalSynth({
            envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
        }).toDestination();
        this.metal.volume.value = -22;
        this.initialized = false;
    }

    async init() {
        if (this.enabled && !this.initialized) {
            await Tone.start();
            this.initialized = true;
        }
    }

    playMove() { if(this.initialized) this.pluck.triggerAttack("C3"); }
    playRotate() { if(this.initialized) this.pluck.triggerAttack("E3"); }
    playDrop() { if(this.initialized) this.metal.triggerAttackRelease("32n"); }
    playLock() { if(this.initialized) this.synth.triggerAttackRelease(["C4", "E4"], "16n"); }
    playLineClear(count) {
        if (!this.initialized) return;
        const notes = count >= 4 ? ["C4", "E4", "G4", "C5", "E5"] : ["C4", "E4", "G4"];
        this.synth.triggerAttackRelease(notes, count >= 4 ? "8n" : "16n");
    }
    playGameOver() { if(this.initialized) this.synth.triggerAttackRelease(["C3", "Bb2", "Ab2", "G2"], "4n"); }
    playHold() { if(this.initialized) this.pluck.triggerAttack("G3"); }
}

class Renderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.glowIntensity = 1;
        this.activeColor = '#ffffff'; 
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        // Use the #app container's size to respect 100dvh
        const app = document.getElementById('app');
        const availableHeight = app.clientHeight - 20; // 20px padding
        const availableWidth = app.clientWidth - 20;

        let cellSize = Math.floor(availableHeight / ROWS);
        const requiredCols = COLS + 5.5; // Left UI (5) + Board (10) + Pad (0.5)

        if (cellSize * requiredCols > availableWidth) {
            cellSize = Math.floor(availableWidth / requiredCols);
        }
        
        this.cellSize = Math.max(cellSize, 10);
        this.boardWidth = this.cellSize * COLS;
        this.boardHeight = this.cellSize * ROWS;
        
        this.sideMarginLeft = this.cellSize * 5; 
        this.sideMarginRight = this.cellSize * 0.5; 
        
        this.canvas.width = this.boardWidth + this.sideMarginLeft + this.sideMarginRight;
        this.canvas.height = this.boardHeight;
        
        this.boardX = this.sideMarginLeft;
        this.boardY = 0;
    }

    clear() {
        this.ctx.fillStyle = COLORS.BG;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawBoard(boardMatrix) {
        this.ctx.strokeStyle = this.activeColor;
        this.ctx.lineWidth = 2;
        this.ctx.globalAlpha = Math.max(0.2, this.glowIntensity); 
        this.ctx.shadowBlur = 10 * this.glowIntensity;
        this.ctx.shadowColor = this.activeColor;
        this.ctx.strokeRect(this.boardX, this.boardY, this.boardWidth, this.boardHeight);
        this.ctx.globalAlpha = 1.0; 
        this.ctx.shadowBlur = 0; 

        boardMatrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    this.drawBlock(this.boardX + x * this.cellSize, this.boardY + y * this.cellSize, COLORS[value], false);
                }
            });
        });
    }

    drawBlock(x, y, color, isGhost = false, isActive = false) {
        const size = this.cellSize;
        if (isGhost) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 1;
            this.ctx.fillRect(x + 1, y + 1, size - 2, size - 2);
            this.ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
            return;
        }
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + 1, y + 1, size - 2, size - 2);
        this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
        this.ctx.fillRect(x + 1, y + 1, size - 2, size/4);
        if (isActive) {
            this.ctx.shadowBlur = 20 * this.glowIntensity;
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x, y, size, size);
            this.ctx.shadowBlur = 0; 
        }
    }

    drawPiece(piece, ghostY) {
        if (!piece) return;
        this.activeColor = COLORS[piece.typeId]; 
        if (ghostY !== null) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const px = this.boardX + (piece.x + x) * this.cellSize;
                        const py = this.boardY + (ghostY + y) * this.cellSize;
                        this.drawBlock(px, py, COLORS[piece.typeId], true);
                    }
                });
            });
        }
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    const px = this.boardX + (piece.x + x) * this.cellSize;
                    const py = this.boardY + (piece.y + y) * this.cellSize;
                    this.drawBlock(px, py, COLORS[piece.typeId], false, true); 
                }
            });
        });
    }

    drawUI(score, lines, nextPiece, holdPiece) {
        const fs = Math.max(9, Math.floor(this.cellSize * 0.4)); // Scale text
        this.ctx.font = `${fs}px "Press Start 2P"`;
        this.ctx.textAlign = 'center';

        const cx = this.sideMarginLeft / 2; // Center of Left Panel
        let y = this.cellSize * 2;

        // --- TITLE ---
        this.ctx.fillStyle = '#888';
        this.ctx.fillText("LEGALLY", cx, y); y += fs * 1.5;
        this.ctx.fillText("DISTINCT", cx, y); y += fs * 1.5;
        this.ctx.fillStyle = '#fff';
        this.ctx.fillText("TETROMINO", cx, y); y += fs * 1.5;
        this.ctx.fillStyle = COLORS.L; // Orange
        this.ctx.fillText("v2", cx, y); y += fs * 3;

        // --- SCORE ---
        this.ctx.fillStyle = '#888';
        this.ctx.fillText("SCORE", cx, y); y += fs * 1.5;
        this.ctx.fillStyle = '#fff';
        this.ctx.font = `${fs+2}px "Press Start 2P"`;
        this.ctx.fillText(score, cx, y); y += fs * 3;

        // --- LINES ---
        this.ctx.font = `${fs}px "Press Start 2P"`;
        this.ctx.fillStyle = '#888';
        this.ctx.fillText("LINES", cx, y); y += fs * 1.5;
        this.ctx.fillStyle = '#fff';
        this.ctx.font = `${fs+2}px "Press Start 2P"`;
        this.ctx.fillText(lines, cx, y); y += fs * 4;

        // --- HOLD ---
        this.ctx.font = `${fs}px "Press Start 2P"`;
        this.ctx.fillStyle = '#aaa';
        this.ctx.fillText("HOLD", cx, y); y += fs * 1.2;
        if (holdPiece) {
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = COLORS[holdPiece];
            this.drawPreviewPiece(holdPiece, cx, y + (this.cellSize)); 
            this.ctx.shadowBlur = 0;
        } else {
            this.ctx.fillStyle = '#333';
            this.ctx.fillText("---", cx, y + (this.cellSize));
        }
        y += this.cellSize * 4; 

        // --- NEXT ---
        this.ctx.fillStyle = '#aaa';
        this.ctx.fillText("NEXT", cx, y); y += fs * 1.2;
        if (nextPiece) {
            this.drawPreviewPiece(nextPiece, cx, y + (this.cellSize));
        }
    }

    drawPreviewPiece(typeId, cx, cy) {
        const shape = SHAPES[typeId];
        const color = COLORS[typeId];
        const size = this.cellSize * 0.7;
        const w = shape[0].length * size;
        const h = shape.length * size;
        const startX = cx - w / 2;
        const startY = cy - h / 2;
        this.ctx.fillStyle = color;
        shape.forEach((row, y) => {
            row.forEach((val, x) => {
                if (val) {
                    this.ctx.fillRect(startX + x * size, startY + y * size, size - 1, size - 1);
                }
            });
        });
    }

    createExplosion(rowIdx) {
        const y = this.boardY + rowIdx * this.cellSize + (this.cellSize/2);
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: this.boardX + Math.random() * this.boardWidth,
                y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1.0,
                color: '#fff'
            });
        }
    }

    drawParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillRect(p.x, p.y, 4, 4);
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.04;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
        this.ctx.globalAlpha = 1.0;
    }

    animateGlow() {
        const time = Date.now() / 1500; 
        this.glowIntensity = 0.5 + Math.sin(time) * 0.4; 
    }

    triggerInputPulse() {
        this.glowIntensity = 1.8; 
    }
}

class Game {
    constructor() {
        this.renderer = new Renderer('game-canvas');
        this.audio = new AudioController();
        this.board = this.createBoard();
        this.bag = [];
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        
        const savedData = JSON.parse(localStorage.getItem('ldt_highscore')) || { name: 'AAA', score: 0 };
        this.highScore = savedData.score;
        this.highScoreName = savedData.name;
        
        this.gameOver = false;
        this.isPaused = false;
        this.currentPiece = null;
        this.nextPieceType = null;
        this.holdPieceType = null;
        this.canHold = true;
        this.dropInterval = 1000;
        this.lastDropTime = 0;

        this.screenStart = document.getElementById('start-screen');
        this.screenGameOver = document.getElementById('game-over-screen');
        this.btnStart = document.getElementById('btn-start');
        this.btnResume = document.getElementById('btn-resume');
        this.btnRestart = document.getElementById('btn-restart');
        this.btnQuit = document.getElementById('btn-quit');
        this.title = document.getElementById('screen-title');
        
        this.uiHighScoreStartVal = document.getElementById('start-high-score-val');
        this.uiHighScoreStartName = document.getElementById('start-high-score-name');
        this.nameInput = document.getElementById('high-score-name');

        this.updateHighScoreDisplay();
        this.bindEvents();
        this.loop = this.loop.bind(this);
        this.requestId = null;
    }

    createBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    updateHighScoreDisplay() {
        if (this.uiHighScoreStartVal) this.uiHighScoreStartVal.innerText = this.highScore;
        if (this.uiHighScoreStartName) this.uiHighScoreStartName.innerText = `(${this.highScoreName})`;
    }

    saveHighScore() {
        if (this.score > this.highScore) {
            let name = this.nameInput.value.trim().toUpperCase() || "ANON";
            this.highScore = this.score;
            this.highScoreName = name;
            localStorage.setItem('ldt_highscore', JSON.stringify({ name: name, score: this.score }));
            this.updateHighScoreDisplay();
        }
    }

    bindEvents() {
        this.btnStart.addEventListener('click', () => { this.audio.init(); this.start(); });
        this.btnResume.addEventListener('click', () => this.togglePause());
        this.btnRestart.addEventListener('click', () => { this.saveHighScore(); this.start(); });
        this.btnQuit.addEventListener('click', () => {
            this.saveHighScore();
            this.screenGameOver.classList.add('hidden');
            this.screenStart.classList.remove('hidden');
            this.title.innerText = "CONTROLS";
            this.btnStart.classList.remove('hidden');
            this.btnResume.classList.add('hidden');
            this.renderer.clear();
        });

        if(this.nameInput) {
             this.nameInput.addEventListener('focus', () => { this.nameInput.select(); });
             this.nameInput.addEventListener('keydown', (e) => { e.stopPropagation(); if (e.key === 'Enter') { this.saveHighScore(); this.start(); } });
        }

        document.addEventListener('keydown', (e) => {
            if (this.gameOver) return;
            if (document.activeElement === this.nameInput) return;
            if (this.isPaused && e.key.toLowerCase() !== 'p') return;
            if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','c',' '].includes(e.key)) { this.renderer.triggerInputPulse(); }

            switch(e.key) {
                case 'ArrowLeft': this.move(-1); break;
                case 'ArrowRight': this.move(1); break;
                case 'ArrowDown': this.drop(); break;
                case 'ArrowUp': this.rotate(); break;
                case ' ': this.hardDrop(); break;
                case 'c': case 'C': this.hold(); break;
                case 'p': case 'P': this.togglePause(); break;
            }
        });

        let touchStartX = 0, touchStartY = 0;
        let longPressTimer = null;
        let isLongPressHandled = false;
        const LONG_PRESS_MS = 300;

        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target === this.nameInput) return;
            
            if (e.touches.length === 2) {
                this.togglePause();
                return;
            }

            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            
            // Start Long Press Timer
            isLongPressHandled = false;
            longPressTimer = setTimeout(() => {
                this.hardDrop();
                isLongPressHandled = true;
                if(navigator.vibrate) navigator.vibrate(50); // Feedback
            }, LONG_PRESS_MS);

            this.renderer.triggerInputPulse();
        }, {passive: false});

        // Add touchmove to cancel long press if dragging
        document.addEventListener('touchmove', (e) => {
             if (e.target.tagName === 'BUTTON' || e.target === this.nameInput) return;
             // Prevent default scrolling
             e.preventDefault(); 
             
             const x = e.changedTouches[0].screenX;
             const y = e.changedTouches[0].screenY;
             
             // If moved more than 10px, cancel long press
             if (Math.abs(x - touchStartX) > 10 || Math.abs(y - touchStartY) > 10) {
                 clearTimeout(longPressTimer);
             }
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target === this.nameInput) return;
            
            clearTimeout(longPressTimer); // Cancel timer
            
            if (this.gameOver || this.isPaused) return;
            if (isLongPressHandled) return; // Already handled

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (absDx < 10 && absDy < 10) {
                this.rotate(); // Single Tap
                return;
            }

            if (absDx > absDy) {
                if (dx > 30) this.move(1); else if (dx < -30) this.move(-1);
            } else {
                if (dy > 30) this.drop(); else if (dy < -30) this.hold();
            }
        }, {passive: false});
    }

    start() {
        this.board = this.createBoard();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.gameOver = false;
        this.isPaused = false;
        this.bag = [];
        this.holdPieceType = null;
        
        this.updateUI();
        this.screenStart.classList.add('hidden');
        this.screenGameOver.classList.add('hidden');
        this.spawnPiece();
        if (this.requestId) cancelAnimationFrame(this.requestId);
        this.lastDropTime = Date.now();
        this.loop();
    }

    togglePause() {
        if (this.gameOver) return;
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            this.title.innerText = "PAUSED";
            this.btnStart.classList.add('hidden');
            this.btnResume.classList.remove('hidden');
            this.screenStart.classList.remove('hidden');
        } else {
            this.screenStart.classList.add('hidden');
            this.lastDropTime = Date.now();
            this.loop();
        }
    }

    endGame() {
        this.gameOver = true;
        this.audio.playGameOver();
        if (this.score > this.highScore) { this.highScore = this.score; }
        
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('final-lines').innerText = this.lines;
        if (this.highScoreName !== 'ANON') { this.nameInput.value = this.highScoreName; }

        this.screenGameOver.classList.remove('hidden');
    }

    loop() {
        if (this.isPaused || this.gameOver) return;
        const now = Date.now();
        const delta = now - this.lastDropTime;
        if (delta > this.dropInterval) { this.drop(); this.lastDropTime = now; }
        this.renderer.animateGlow();
        this.renderer.clear();
        this.renderer.drawBoard(this.board);
        let ghostY = null;
        if (this.currentPiece) {
            ghostY = this.currentPiece.y;
            while (this.isValid(0, 1, this.currentPiece.shape, this.currentPiece.x, ghostY)) { ghostY++; }
        }
        this.renderer.drawPiece(this.currentPiece, ghostY);
        this.renderer.drawParticles();
        this.renderer.drawUI(this.score, this.lines, this.nextPieceType, this.holdPieceType);
        this.requestId = requestAnimationFrame(this.loop);
    }

    getPieceType() {
        if (this.bag.length === 0) {
            this.bag = ['I','J','L','O','S','T','Z'];
            for (let i = this.bag.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [this.bag[i], this.bag[j]] = [this.bag[j], this.bag[i]]; }
        }
        return this.bag.pop();
    }
    spawnPiece() {
        if (!this.nextPieceType) this.nextPieceType = this.getPieceType();
        const type = this.nextPieceType;
        this.nextPieceType = this.getPieceType();
        this.currentPiece = { typeId: type, shape: SHAPES[type], x: 3, y: 0 };
        if (!this.isValid(0, 0)) { this.endGame(); }
        this.canHold = true;
    }
    hold() {
        if (!this.canHold || this.isPaused || this.gameOver) return;
        this.audio.playHold();
        if (this.holdPieceType === null) {
            this.holdPieceType = this.currentPiece.typeId;
            this.spawnPiece();
        } else {
            const temp = this.currentPiece.typeId;
            this.currentPiece = { typeId: this.holdPieceType, shape: SHAPES[this.holdPieceType], x: 3, y: 0 };
            this.holdPieceType = temp;
        }
    }
    move(dir) { if (this.isValid(dir, 0)) { this.currentPiece.x += dir; this.audio.playMove(); } }
    rotate() {
        const piece = this.currentPiece;
        const temp = JSON.parse(JSON.stringify(piece.shape));
        for (let y = 0; y < temp.length; ++y) { for (let x = 0; x < y; ++x) { [temp[x][y], temp[y][x]] = [temp[y][x], temp[x][y]]; } }
        temp.forEach(row => row.reverse());
        if (this.isValid(0, 0, temp)) { piece.shape = temp; this.audio.playRotate(); }
        else { if (this.isValid(1, 0, temp)) { piece.x += 1; piece.shape = temp; this.audio.playRotate(); } else if (this.isValid(-1, 0, temp)) { piece.x -= 1; piece.shape = temp; this.audio.playRotate(); } }
    }
    drop() { if (this.isValid(0, 1)) { this.currentPiece.y++; } else { this.lock(); } }
    hardDrop() { while (this.isValid(0, 1)) { this.currentPiece.y++; } this.audio.playDrop(); this.lock(); }
    isValid(offsetX, offsetY, shape = this.currentPiece.shape, pX = this.currentPiece.x, pY = this.currentPiece.y) {
        for (let y = 0; y < shape.length; y++) { for (let x = 0; x < shape[y].length; x++) { if (shape[y][x]) { const newX = pX + x + offsetX; const newY = pY + y + offsetY; if (newX < 0 || newX >= COLS || newY >= ROWS) return false; if (newY >= 0 && this.board[newY][newX]) return false; } } }
        return true;
    }
    lock() {
        this.audio.playLock();
        this.currentPiece.shape.forEach((row, y) => { row.forEach((val, x) => { if (val) { const by = this.currentPiece.y + y; const bx = this.currentPiece.x + x; if (by >= 0) this.board[by][bx] = this.currentPiece.typeId; } }); });
        this.checkLines();
        this.spawnPiece();
    }
    checkLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (this.board[y].every(cell => cell !== 0)) {
                this.board.splice(y, 1);
                this.board.unshift(Array(COLS).fill(0));
                this.renderer.createExplosion(y);
                linesCleared++;
                y++;
            }
        }
        if (linesCleared > 0) {
            this.lines += linesCleared;
            const points = [0, 40, 100, 300, 1200];
            this.score += points[linesCleared] * this.level;
            this.audio.playLineClear(linesCleared);
            if (this.lines > this.level * 10) { this.level++; this.dropInterval = Math.max(100, 1000 - (this.level * 50)); }
        }
    }
    updateUI() {
        // Redraw UI on every update in case score/lines change
        // In this canvas implementation, the loop() handles drawing, but we update text if needed?
        // Actually, loop() draws UI every frame, so we don't need manual DOM updates unless we used DOM overlays.
        // Wait, the UI (Score/Lines) is drawn on canvas in drawUI().
    }
}

const game = new Game();
</script>
</body>
</html>
