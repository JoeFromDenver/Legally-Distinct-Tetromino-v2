<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Legally Distinct Tetromino v2</title>
    
    <!-- Local Audio Engine (Offline Capable) -->
    <script src="./js/Tone.js"></script>
    
    <!-- Google Font (Note: Fonts still require internet unless downloaded locally) -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#202124">

    <style>
        :root {
            --bg-color: #202124;
            --ui-bg: #2d2e31;
            --text-color: #f0f0f0;
            --accent-color: #fb8c00; /* Magic Orange */
            --font-main: 'Press Start 2P', monospace;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px; /* Mobile constraint */
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Header --- */
        header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        h1 {
            font-size: 12px;
            line-height: 1.6;
            margin: 0;
            text-align: left;
            color: #fff;
            text-shadow: 2px 2px 0px #000;
        }

        /* --- Canvas Layer --- */
        #game-canvas {
            display: block;
            margin: 0 auto;
        }

        /* --- UI Overlay Layer --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            background: rgba(32, 33, 36, 0.98);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #444;
            pointer-events: auto; /* Re-enable clicks for buttons */
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            width: 90%;
            max-width: 380px;
        }

        .hidden { display: none !important; }

        h2 { font-size: 20px; margin-bottom: 20px; color: var(--accent-color); }
        
        /* Stats row for Game Over / Pause */
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 12px;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        .stat-val { color: #fff; }
        .high-score { color: #fcbf49; } /* Gold color for high score */

        button {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 18px 20px;
            font-family: var(--font-main);
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            box-shadow: 0 4px 0 #0d47a1;
            transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #0d47a1; }
        button.secondary { background: #555; box-shadow: 0 4px 0 #333; }
        button.secondary:active { box-shadow: 0 0 0 #333; }

        /* --- New Controls Grid Layout --- */
        .controls-grid {
            display: grid;
            grid-template-columns: max-content 1fr; /* Action takes min space, Inputs take rest */
            gap: 12px 20px;
            text-align: left;
            margin-bottom: 25px;
            width: 100%;
            align-items: center;
        }

        .control-label {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-inputs {
            text-align: right;
            font-size: 10px;
            color: #fff;
        }

        /* UPDATED: Flexbox-based Key Styling for Uniformity */
        .key {
            display: inline-flex;       /* Use flexbox to center content */
            justify-content: center;    /* Center horizontally */
            align-items: center;        /* Center vertically */
            background: #444;
            padding: 0 6px;             /* Horizontal padding only */
            border-radius: 4px;
            color: #fcbf49;
            border-bottom: 2px solid #222;
            font-size: 9px;
            margin: 0 2px;
            height: 22px;               /* Fixed Height */
            min-width: 22px;            /* Fixed Minimum Width (forces square for single chars) */
            line-height: normal;        /* Reset line-height to let flex handle centering */
            vertical-align: middle;     /* Align with text around it */
        }
        
        /* New Arrow Icon Style */
        .arrow-icon {
            width: 10px;
            height: 10px;
            fill: currentColor;
            display: block;
        }
        
        .divider {
            color: #666;
            font-size: 8px;
            margin: 0 2px;
            vertical-align: middle;
        }

        /* --- Virtual Controls Hidden (Gesture Only) --- */
        #virtual-controls { display: none; }

    </style>
</head>
<body>

<div id="app">
    <!-- Header with Stats -->
    <header>
        <h1>Legally Distinct<br><span style="color:var(--accent-color)">Tetromino v2</span></h1>
        <div style="text-align: right; font-size: 10px;">
            <div style="color:#888; margin-bottom:2px;">SCORE</div>
            <div id="score-val" style="font-size: 14px; margin-bottom:6px; color:#fff;">0</div>
            <div style="color:#888; margin-bottom:2px;">LINES</div>
            <div id="lines-val" style="font-size: 14px; color:#fff;">0</div>
        </div>
    </header>

    <!-- Main Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Start / Pause / Controls Screen -->
        <div id="start-screen" class="screen">
            <h2 id="screen-title">CONTROLS</h2>
            
            <!-- High Score Display on Start -->
            <div id="start-high-score" class="stat-row" style="margin-bottom: 20px; justify-content: center; border: none;">
                <span style="color: #fcbf49;">BEST: <span id="start-high-score-val">0</span></span>
            </div>

            <!-- Redesigned Controls Grid -->
            <div class="controls-grid">
                <div class="control-label">Move</div>
                <div class="control-inputs">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M7 2 L3 5 L7 8 Z"/></svg></span> / <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M3 2 L7 5 L3 8 Z"/></svg></span> <span class="divider">or</span> <span class="key">Swipe</span>
                </div>

                <div class="control-label">Rotate</div>
                <div class="control-inputs">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M2 7 L5 3 L8 7 Z"/></svg></span> <span class="divider">or</span> <span class="key">Tap</span>
                </div>

                <div class="control-label">Soft Drop</div>
                <div class="control-inputs">
                    <span class="key"><svg class="arrow-icon" viewBox="0 0 10 10"><path d="M2 3 L5 7 L8 3 Z"/></svg></span> <span class="divider">or</span> <span class="key">Swipe ↓</span>
                </div>

                <div class="control-label">Hold Piece</div>
                <div class="control-inputs">
                    <span class="key">C</span> <span class="divider">or</span> <span class="key">Swipe ↑</span>
                </div>

                <div class="control-label">Hard Drop</div>
                <div class="control-inputs">
                    <span class="key">Space</span> <span class="divider">or</span> <span class="key">Dbl Tap</span>
                </div>

                <div class="control-label">Pause</div>
                <div class="control-inputs">
                    <span class="key">P</span> <span class="divider">or</span> <span class="key">2-Finger</span>
                </div>
            </div>

            <button id="btn-start">START GAME</button>
            <button id="btn-resume" class="hidden">RESUME</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <h2 style="color:#ff5252">GAME OVER</h2>
            <div class="stat-row"><span>Final Score</span><span class="stat-val" id="final-score">0</span></div>
            <div class="stat-row"><span>High Score</span><span class="stat-val high-score" id="final-high-score">0</span></div>
            <div class="stat-row"><span>Lines Cleared</span><span class="stat-val" id="final-lines">0</span></div>
            <br>
            <button id="btn-restart">TRY AGAIN</button>
            <button id="btn-quit" class="secondary">QUIT</button>
        </div>
    </div>
</div>

<script>
// Check for Tone.js (Warning if not downloaded)
if (typeof Tone === 'undefined') {
    alert("Warning: Tone.js not found. Audio will not work.\nPlease ensure 'js/Tone.js' exists locally.");
}

// Service Worker Registration
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('Service Worker registered!', reg))
            .catch(err => console.log('Service Worker registration failed', err));
    });
}

/**
 * ------------------------------------------------------------------
 * CONSTANTS & CONFIG
 * ------------------------------------------------------------------
 */
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30; // Base size, scaled by canvas
const COLORS = {
    I: '#00f0f0', O: '#f0f000', T: '#a000f0', S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#f0a000',
    GHOST: 'rgba(255, 255, 255, 0.15)',
    BG: '#202124',
    GRID: '#2d2e31'
};

const SHAPES = {
    I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    J: [[1,0,0], [1,1,1], [0,0,0]],
    L: [[0,0,1], [1,1,1], [0,0,0]],
    O: [[1,1], [1,1]],
    S: [[0,1,1], [1,1,0], [0,0,0]],
    T: [[0,1,0], [1,1,1], [0,0,0]],
    Z: [[1,1,0], [0,1,1], [0,0,0]]
};

/**
 * ------------------------------------------------------------------
 * AUDIO ENGINE (Tone.js)
 * ------------------------------------------------------------------
 */
class AudioController {
    constructor() {
        if (typeof Tone === 'undefined') return;
        this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
        this.synth.volume.value = -12;
        this.pluck = new Tone.PluckSynth().toDestination();
        this.pluck.volume.value = -8;
        this.metal = new Tone.MetalSynth({
            envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
        }).toDestination();
        this.metal.volume.value = -22;
        this.initialized = false;
    }

    async init() {
        if (typeof Tone !== 'undefined' && !this.initialized) {
            await Tone.start();
            this.initialized = true;
        }
    }

    playMove() { if(this.initialized) this.pluck.triggerAttack("C3"); }
    playRotate() { if(this.initialized) this.pluck.triggerAttack("E3"); }
    playDrop() { if(this.initialized) this.metal.triggerAttackRelease("32n"); }
    playLock() { if(this.initialized) this.synth.triggerAttackRelease(["C4", "E4"], "16n"); }
    playLineClear(count) {
        if (!this.initialized) return;
        if (count >= 4) this.synth.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "8n");
        else this.synth.triggerAttackRelease(["C4", "E4", "G4"], "16n");
    }
    playGameOver() { if(this.initialized) this.synth.triggerAttackRelease(["C3", "Bb2", "Ab2", "G2"], "4n"); }
    playHold() { if(this.initialized) this.pluck.triggerAttack("G3"); }
}

/**
 * ------------------------------------------------------------------
 * RENDERER (Canvas)
 * ------------------------------------------------------------------
 */
class Renderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.glowIntensity = 0;
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        const headerHeight = 80;
        const availableHeight = window.innerHeight - headerHeight - 20; 
        const availableWidth = window.innerWidth - 20;

        let cellSize = Math.floor(availableHeight / ROWS);
        if (cellSize * COLS > availableWidth) {
            cellSize = Math.floor(availableWidth / COLS);
        }
        
        this.cellSize = cellSize;
        this.boardWidth = this.cellSize * COLS;
        this.boardHeight = this.cellSize * ROWS;
        
        this.sideMargin = this.cellSize * 4; 
        
        this.canvas.width = this.boardWidth + (this.sideMargin * 2);
        this.canvas.height = this.boardHeight;
        
        this.boardX = this.sideMargin;
        this.boardY = 0;
    }

    clear() {
        this.ctx.fillStyle = COLORS.BG;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawBoard(boardMatrix) {
        this.ctx.strokeStyle = COLORS.GRID;
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(this.boardX, this.boardY, this.boardWidth, this.boardHeight);

        boardMatrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    this.drawBlock(this.boardX + x * this.cellSize, this.boardY + y * this.cellSize, COLORS[value], false);
                }
            });
        });
    }

    drawBlock(x, y, color, isGhost = false, isGlowy = false) {
        const size = this.cellSize;
        
        if (isGhost) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 1;
            this.ctx.fillRect(x + 1, y + 1, size - 2, size - 2);
            this.ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
            return;
        }

        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + 1, y + 1, size - 2, size - 2);

        this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
        this.ctx.fillRect(x + 1, y + 1, size - 2, size/4);
        
        if (isGlowy) {
            this.ctx.shadowBlur = 15 * this.glowIntensity;
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x, y, size, size);
            this.ctx.shadowBlur = 0; 
        }
    }

    drawPiece(piece, ghostY) {
        if (!piece) return;

        if (ghostY !== null) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const px = this.boardX + (piece.x + x) * this.cellSize;
                        const py = this.boardY + (ghostY + y) * this.cellSize;
                        this.drawBlock(px, py, COLORS[piece.typeId], true);
                    }
                });
            });
        }

        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    const px = this.boardX + (piece.x + x) * this.cellSize;
                    const py = this.boardY + (piece.y + y) * this.cellSize;
                    this.drawBlock(px, py, COLORS[piece.typeId], false, true);
                }
            });
        });
    }

    drawUI(score, lines, nextPiece, holdPiece) {
        this.ctx.fillStyle = '#aaa';
        this.ctx.font = '10px "Press Start 2P"';
        this.ctx.textAlign = 'center';

        const leftCenter = this.boardX / 2;
        this.ctx.fillText("HOLD", leftCenter, 30);
        if (holdPiece) {
            this.drawPreviewPiece(holdPiece, leftCenter, 80); 
        } else {
            this.ctx.fillStyle = '#333';
            this.ctx.fillText("---", leftCenter, 80);
        }

        const rightCenter = this.boardX + this.boardWidth + (this.sideMargin / 2);
        this.ctx.fillStyle = '#aaa';
        this.ctx.fillText("NEXT", rightCenter, 30);
        if (nextPiece) {
            this.drawPreviewPiece(nextPiece, rightCenter, 80); 
        }
    }

    drawPreviewPiece(typeId, cx, cy) {
        const shape = SHAPES[typeId];
        const color = COLORS[typeId];
        const size = this.cellSize * 0.7;
        
        const w = shape[0].length * size;
        const h = shape.length * size;
        const startX = cx - w / 2;
        const startY = cy - h / 2;

        this.ctx.fillStyle = color;
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = color;
        
        shape.forEach((row, y) => {
            row.forEach((val, x) => {
                if (val) {
                    this.ctx.fillRect(startX + x * size, startY + y * size, size - 1, size - 1);
                }
            });
        });
        this.ctx.shadowBlur = 0;
    }

    createExplosion(rowIdx) {
        const y = this.boardY + rowIdx * this.cellSize + (this.cellSize/2);
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: this.boardX + Math.random() * this.boardWidth,
                y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1.0,
                color: '#fff'
            });
        }
    }

    drawParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillRect(p.x, p.y, 4, 4);
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.04;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
        this.ctx.globalAlpha = 1.0;
    }

    animateGlow() {
        const time = Date.now() / 500; 
        this.glowIntensity = 1 + Math.sin(time) * 0.5;
    }
}

/**
 * ------------------------------------------------------------------
 * GAME LOGIC
 * ------------------------------------------------------------------
 */
class Game {
    constructor() {
        this.renderer = new Renderer('game-canvas');
        this.audio = new AudioController();
        this.board = this.createBoard();
        this.bag = [];
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.highScore = parseInt(localStorage.getItem('tetromino_highscore')) || 0;
        
        this.gameOver = false;
        this.isPaused = false;
        this.currentPiece = null;
        this.nextPieceType = null;
        this.holdPieceType = null;
        this.canHold = true;
        this.dropInterval = 1000;
        this.lastDropTime = 0;

        // UI Refs
        this.uiScore = document.getElementById('score-val');
        this.uiLines = document.getElementById('lines-val');
        this.screenStart = document.getElementById('start-screen');
        this.screenGameOver = document.getElementById('game-over-screen');
        this.btnStart = document.getElementById('btn-start');
        this.btnResume = document.getElementById('btn-resume');
        this.btnRestart = document.getElementById('btn-restart');
        this.btnQuit = document.getElementById('btn-quit');
        this.title = document.getElementById('screen-title');
        
        // High Score Elements
        this.uiHighScoreStart = document.getElementById('start-high-score-val');
        this.uiHighScoreFinal = document.getElementById('final-high-score');
        
        // Init High Score Display
        this.updateHighScoreDisplay();

        this.bindEvents();
        this.loop = this.loop.bind(this);
        this.requestId = null;
    }

    createBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    updateHighScoreDisplay() {
        this.uiHighScoreStart.innerText = this.highScore;
        this.uiHighScoreFinal.innerText = this.highScore;
    }

    bindEvents() {
        this.btnStart.addEventListener('click', () => { this.audio.init(); this.start(); });
        this.btnResume.addEventListener('click', () => this.togglePause());
        this.btnRestart.addEventListener('click', () => this.start());
        this.btnQuit.addEventListener('click', () => {
            // Quit to start screen
            this.screenGameOver.classList.add('hidden');
            this.screenStart.classList.remove('hidden');
            this.title.innerText = "CONTROLS";
            this.btnStart.classList.remove('hidden');
            this.btnResume.classList.add('hidden');
            this.renderer.clear(); // clear board
        });

        document.addEventListener('keydown', (e) => {
            if (this.gameOver) return;
            if (this.isPaused && e.key.toLowerCase() !== 'p') return;
            switch(e.key) {
                case 'ArrowLeft': this.move(-1); break;
                case 'ArrowRight': this.move(1); break;
                case 'ArrowDown': this.drop(); break;
                case 'ArrowUp': this.rotate(); break;
                case ' ': this.hardDrop(); break;
                case 'c': case 'C': this.hold(); break;
                case 'p': case 'P': this.togglePause(); break;
            }
        });

        // Touch handling
        let touchStartX = 0, touchStartY = 0;
        let lastTap = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            
            // 2-Finger Tap for Pause
            if (e.touches.length === 2) {
                this.togglePause();
                return;
            }

            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            if (this.gameOver || this.isPaused) return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            // Tap Detection
            if (absDx < 10 && absDy < 10) {
                const now = Date.now();
                if (now - lastTap < 300) {
                    this.hardDrop(); // Double tap
                } else {
                    this.rotate(); // Single tap
                }
                lastTap = now;
                return;
            }

            // Swipe Detection
            if (absDx > absDy) {
                // Horizontal
                if (dx > 30) this.move(1);
                else if (dx < -30) this.move(-1);
            } else {
                // Vertical
                if (dy > 30) this.drop(); // Swipe Down = Drop
                else if (dy < -30) this.hold(); // Swipe Up = Hold
            }
        }, {passive: false});
    }

    start() {
        this.board = this.createBoard();
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.gameOver = false;
        this.isPaused = false;
        this.bag = [];
        this.holdPieceType = null;
        this.canHold = true;
        this.updateUI();
        this.screenStart.classList.add('hidden');
        this.screenGameOver.classList.add('hidden');
        this.spawnPiece();
        if (this.requestId) cancelAnimationFrame(this.requestId);
        this.lastDropTime = Date.now();
        this.loop();
    }

    togglePause() {
        if (this.gameOver) return;
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            this.title.innerText = "PAUSED";
            this.btnStart.classList.add('hidden');
            this.btnResume.classList.remove('hidden');
            this.screenStart.classList.remove('hidden');
        } else {
            this.screenStart.classList.add('hidden');
            this.lastDropTime = Date.now();
            this.loop();
        }
    }

    endGame() {
        this.gameOver = true;
        this.audio.playGameOver();
        
        // High Score Check
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('tetromino_highscore', this.highScore);
        }
        
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('final-lines').innerText = this.lines;
        this.updateHighScoreDisplay();
        
        this.screenGameOver.classList.remove('hidden');
    }

    loop() {
        if (this.isPaused || this.gameOver) return;
        const now = Date.now();
        const delta = now - this.lastDropTime;
        if (delta > this.dropInterval) {
            this.drop();
            this.lastDropTime = now;
        }
        this.renderer.animateGlow();
        this.renderer.clear();
        this.renderer.drawBoard(this.board);
        let ghostY = null;
        if (this.currentPiece) {
            ghostY = this.currentPiece.y;
            while (this.isValid(0, 1, this.currentPiece.shape, this.currentPiece.x, ghostY)) {
                ghostY++;
            }
        }
        this.renderer.drawPiece(this.currentPiece, ghostY);
        this.renderer.drawParticles();
        this.renderer.drawUI(this.score, this.lines, this.nextPieceType, this.holdPieceType);
        this.requestId = requestAnimationFrame(this.loop);
    }

    getPieceType() {
        if (this.bag.length === 0) {
            this.bag = ['I','J','L','O','S','T','Z'];
            for (let i = this.bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.bag[i], this.bag[j]] = [this.bag[j], this.bag[i]];
            }
        }
        return this.bag.pop();
    }

    spawnPiece() {
        if (!this.nextPieceType) this.nextPieceType = this.getPieceType();
        const type = this.nextPieceType;
        this.nextPieceType = this.getPieceType();
        this.currentPiece = { typeId: type, shape: SHAPES[type], x: 3, y: 0 };
        if (!this.isValid(0, 0)) { this.endGame(); }
        this.canHold = true;
    }

    hold() {
        if (!this.canHold || this.isPaused || this.gameOver) return;
        this.audio.playHold();
        if (this.holdPieceType === null) {
            this.holdPieceType = this.currentPiece.typeId;
            this.spawnPiece();
        } else {
            const temp = this.currentPiece.typeId;
            this.currentPiece = { typeId: this.holdPieceType, shape: SHAPES[this.holdPieceType], x: 3, y: 0 };
            this.holdPieceType = temp;
        }
        this.canHold = false;
    }

    move(dir) { if (this.isValid(dir, 0)) { this.currentPiece.x += dir; this.audio.playMove(); } }

    rotate() {
        const piece = this.currentPiece;
        const temp = JSON.parse(JSON.stringify(piece.shape));
        for (let y = 0; y < temp.length; ++y) {
            for (let x = 0; x < y; ++x) { [temp[x][y], temp[y][x]] = [temp[y][x], temp[x][y]]; }
        }
        temp.forEach(row => row.reverse());
        if (this.isValid(0, 0, temp)) { piece.shape = temp; this.audio.playRotate(); }
        else {
            if (this.isValid(1, 0, temp)) { piece.x += 1; piece.shape = temp; this.audio.playRotate(); }
            else if (this.isValid(-1, 0, temp)) { piece.x -= 1; piece.shape = temp; this.audio.playRotate(); }
        }
    }

    drop() { if (this.isValid(0, 1)) { this.currentPiece.y++; } else { this.lock(); } }

    hardDrop() { while (this.isValid(0, 1)) { this.currentPiece.y++; } this.audio.playDrop(); this.lock(); }

    isValid(offsetX, offsetY, shape = this.currentPiece.shape, pX = this.currentPiece.x, pY = this.currentPiece.y) {
        for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                    const newX = pX + x + offsetX;
                    const newY = pY + y + offsetY;
                    if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                    if (newY >= 0 && this.board[newY][newX]) return false;
                }
            }
        }
        return true;
    }

    lock() {
        this.audio.playLock();
        this.currentPiece.shape.forEach((row, y) => {
            row.forEach((val, x) => {
                if (val) {
                    const by = this.currentPiece.y + y;
                    const bx = this.currentPiece.x + x;
                    if (by >= 0) this.board[by][bx] = this.currentPiece.typeId;
                }
            });
        });
        this.checkLines();
        this.spawnPiece();
    }

    checkLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (this.board[y].every(cell => cell !== 0)) {
                this.board.splice(y, 1);
                this.board.unshift(Array(COLS).fill(0));
                this.renderer.createExplosion(y);
                linesCleared++;
                y++;
            }
        }
        if (linesCleared > 0) {
            this.lines += linesCleared;
            const points = [0, 40, 100, 300, 1200];
            this.score += points[linesCleared] * this.level;
            this.audio.playLineClear(linesCleared);
            this.updateUI();
            if (this.lines > this.level * 10) {
                this.level++;
                this.dropInterval = Math.max(100, 1000 - (this.level * 50));
            }
        }
    }

    updateUI() {
        this.uiScore.innerText = this.score;
        this.uiLines.innerText = this.lines;
    }
}

const game = new Game();
</script>
</body>
</html>
